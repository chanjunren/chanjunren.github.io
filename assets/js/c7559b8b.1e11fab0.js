"use strict";(self.webpackChunkliangzai_for_hire=self.webpackChunkliangzai_for_hire||[]).push([[7888],{5680:(e,n,t)=>{t.d(n,{xA:()=>c,yg:()=>f});var r=t(6540);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,r,i=function(e,n){if(null==e)return{};var t,r,i={},a=Object.keys(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var l=r.createContext({}),p=function(e){var n=r.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},c=function(e){var n=p(e.components);return r.createElement(l.Provider,{value:n},e.children)},y="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},d=r.forwardRef((function(e,n){var t=e.components,i=e.mdxType,a=e.originalType,l=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),y=p(t),d=i,f=y["".concat(l,".").concat(d)]||y[d]||u[d]||a;return t?r.createElement(f,s(s({ref:n},c),{},{components:t})):r.createElement(f,s({ref:n},c))}));function f(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var a=t.length,s=new Array(a);s[0]=d;var o={};for(var l in n)hasOwnProperty.call(n,l)&&(o[l]=n[l]);o.originalType=e,o[y]="string"==typeof e?e:i,s[1]=o;for(var p=2;p<a;p++)s[p]=t[p];return r.createElement.apply(null,s)}return r.createElement.apply(null,t)}d.displayName="MDXCreateElement"},3473:(e,n,t)=>{t.r(n),t.d(n,{contentTitle:()=>s,default:()=>y,frontMatter:()=>a,metadata:()=>o,toc:()=>l});var r=t(8168),i=(t(6540),t(5680));const a={},s="Types vs Interfaces",o={unversionedId:"Frontend/Typescript/typesVsInterfaces",id:"Frontend/Typescript/typesVsInterfaces",title:"Types vs Interfaces",description:"Types (Type Aliases)",source:"@site/docs/Frontend/Typescript/typesVsInterfaces.md",sourceDirName:"Frontend/Typescript",slug:"/Frontend/Typescript/typesVsInterfaces",permalink:"/docs/Frontend/Typescript/typesVsInterfaces",tags:[],version:"current",frontMatter:{},sidebar:"docs",previous:{title:"Typescript",permalink:"/docs/Frontend/Typescript/"},next:{title:"Miscellaneous",permalink:"/docs/Misc/"}},l=[{value:"Types (Type Aliases)",id:"types-type-aliases",children:[],level:2},{value:"Interfaces",id:"interfaces",children:[],level:2},{value:"Key Differences",id:"key-differences",children:[],level:2},{value:"Usage Recommendations",id:"usage-recommendations",children:[],level:2}],p={toc:l},c="wrapper";function y(e){let{components:n,...t}=e;return(0,i.yg)(c,(0,r.A)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,i.yg)("h1",{id:"types-vs-interfaces"},"Types vs Interfaces"),(0,i.yg)("h2",{id:"types-type-aliases"},"Types (Type Aliases)"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Definition: Declared using type keyword."),(0,i.yg)("li",{parentName:"ul"},"Union Types: Can define union types. For example, type StringOrNumber = string | number;."),(0,i.yg)("li",{parentName:"ul"},"Computed Properties: Can use computed properties (mapped types)."),(0,i.yg)("li",{parentName:"ul"},"Extending Types: Can extend other types using intersections. For example, type ExtendedType = BaseType & { newProp: string };."),(0,i.yg)("li",{parentName:"ul"},"Immutability: Can define immutable properties using readonly."),(0,i.yg)("li",{parentName:"ul"},"Tuples and Arrays: More flexible in defining tuple and array types.")),(0,i.yg)("h2",{id:"interfaces"},"Interfaces"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Definition: Declared using interface keyword."),(0,i.yg)("li",{parentName:"ul"},"Extensibility: Can be extended using extends keyword. For example, interface ExtendedInterface extends BaseInterface { newProp: string; }."),(0,i.yg)("li",{parentName:"ul"},"Implementation: Classes can implement interfaces."),(0,i.yg)("li",{parentName:"ul"},"Merging: Supports declaration merging (two declarations with the same name are merged into one)."),(0,i.yg)("li",{parentName:"ul"},"Methods: Can declare methods and also mark them as optional."),(0,i.yg)("li",{parentName:"ul"},"Index Signatures: Supports index signatures for dynamic properties.")),(0,i.yg)("h2",{id:"key-differences"},"Key Differences"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Extensibility: Interfaces are often preferred for public API's definition due to their extendibility. While types can be extended using intersections, interfaces can be more intuitively extended with the extends keyword."),(0,i.yg)("li",{parentName:"ul"},"Declaration Merging: Interfaces can have multiple merged declarations, but types cannot."),(0,i.yg)("li",{parentName:"ul"},"Union Types: Types can express union types, whereas interfaces cannot."),(0,i.yg)("li",{parentName:"ul"},"Computed Properties: Types can use computed properties, which interfaces cannot."),(0,i.yg)("li",{parentName:"ul"},"Flexibility in Tuples/Arrays: Types offer more options in defining tuples and arrays.")),(0,i.yg)("h2",{id:"usage-recommendations"},"Usage Recommendations"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Interfaces for API's and Libraries: For defining shapes of objects and classes, especially in libraries and public API's, interfaces are recommended due to their extendibility and declaration merging features."),(0,i.yg)("li",{parentName:"ul"},"Types for Complex Type Expressions: When you need to define unions, intersections, or tuples, or when you work with complex type transformations, type aliases are more suitable."),(0,i.yg)("li",{parentName:"ul"},"In practice, the choice between type and interface can sometimes come down to personal or team preference, especially in cases where their functionality overlaps. However, understanding their differences is crucial for leveraging TypeScript's capabilities effectively.")))}y.isMDXComponent=!0}}]);