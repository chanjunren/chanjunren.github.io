üóìÔ∏è 22012025 2351
üìé

# ddia_chapter_3


On the most fundamental level, a database needs to do two things: when you give it some data, it should store the data, and when you ask it again later, it should give the data back to you. In Chapter 2 we discussed data models and query languages‚Äîi.e., the format in which you (the application developer) give the database your data, and the mecha‚Äê nism by which you can ask for it again later. In this chapter we discuss the same from the database‚Äôs point of view: how we can store the data that we‚Äôre given, and how we can find it again when we‚Äôre asked for it. Why should you, as an application developer, care how the database handles storage and retrieval internally? You‚Äôre probably not going to implement your own storage engine from scratch, but you do need to select a storage engine that is appropriate for your application, from the many that are available. In order to tune a storage engine to perform well on your kind of workload, you need to have a rough idea of what the storage engine is doing under the hood. In particular, there is a big difference between storage engines that are optimized for transactional workloads and those that are optimized for analytics. We will explore that distinction later in ‚ÄúTransaction Processing or Analytics?‚Äù on page 90, and in ‚ÄúColumn-Oriented Storage‚Äù on page 95 we‚Äôll discuss a family of storage engines that is optimized for analytics. However, first we‚Äôll start this chapter by talking about storage engines that are used in the kinds of databases that you‚Äôre probably familiar with: traditional relational data‚Äê bases, and also most so-called NoSQL databases. We will examine two families of 69 storage engines: log-structured storage engines, and page-oriented storage engines such as B-trees.


Summary In this chapter we tried to get to the bottom of how databases handle storage and retrieval. What happens when you store data in a database, and what does the data‚Äê base do when you query for the data again later? On a high level, we saw that storage engines fall into two broad categories: those opti‚Äê mized for transaction processing (OLTP), and those optimized for analytics (OLAP). There are big differences between the access patterns in those use cases: ‚Ä¢ OLTP systems are typically user-facing, which means that they may see a huge volume of requests. In order to handle the load, applications usually only touch a small number of records in each query. The application requests records using some kind of key, and the storage engine uses an index to find the data for the requested key. Disk seek time is often the bottleneck here. ‚Ä¢ Data warehouses and similar analytic systems are less well known, because they are primarily used by business analysts, not by end users. They handle a much lower volume of queries than OLTP systems, but each query is typically very demanding, requiring many millions of records to be scanned in a short time. Disk bandwidth (not seek time) is often the bottleneck here, and columnoriented storage is an increasingly popular solution for this kind of workload. On the OLTP side, we saw storage engines from two main schools of thought: ‚Ä¢ The log-structured school, which only permits appending to files and deleting obsolete files, but never updates a file that has been written. Bitcask, SSTables, LSM-trees, LevelDB, Cassandra, HBase, Lucene, and others belong to this group. ‚Ä¢ The update-in-place school, which treats the disk as a set of fixed-size pages that can be overwritten. B-trees are the biggest example of this philosophy, being used in all major relational databases and also many nonrelational ones. Log-structured storage engines are a comparatively recent development. Their key idea is that they systematically turn random-access writes into sequential writes on disk, which enables higher write throughput due to the performance characteristics of hard drives and SSDs. Summary | 103 Finishing off the OLTP side, we did a brief tour through some more complicated indexing structures, and databases that are optimized for keeping all data in memory. We then took a detour from the internals of storage engines to look at the high-level architecture of a typical data warehouse. This background illustrated why analytic workloads are so different from OLTP: when your queries require sequentially scan‚Äê ning across a large number of rows, indexes are much less relevant. Instead it becomes important to encode data very compactly, to minimize the amount of data that the query needs to read from disk. We discussed how column-oriented storage helps achieve this goal. As an application developer, if you‚Äôre armed with this knowledge about the internals of storage engines, you are in a much better position to know which tool is best suited for your particular application. If you need to adjust a database‚Äôs tuning parameters, this understanding allows you to imagine what effect a higher or a lower value may have. Although this chapter couldn‚Äôt make you an expert in tuning any one particular stor‚Äê age engine, it has hopefully equipped you with enough vocabulary and ideas that you can make sense of the documentation for the database of your choice.


---

# References
